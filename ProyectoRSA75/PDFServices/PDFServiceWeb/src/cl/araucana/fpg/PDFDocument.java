

/*
 * @(#) PDFDocument.java    1.0 05-04-2008
 *
 * Este código fuente pertenece a la Caja de Compensación de Asignación Familiar
 * La Araucana (C.C.A.F.). Su utilización y reproducción es confidencial y está
 * restringido a los sistemas de información propios de la institución.
 */


package cl.araucana.fpg;


import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import cl.araucana.core.util.AbsoluteDate;
import cl.araucana.core.util.AbsoluteDateTime;
import cl.araucana.core.util.AbsoluteTime;
import cl.araucana.core.util.ByteArray;
import cl.araucana.core.util.Padder;
import cl.araucana.core.util.TimeZone;
import cl.araucana.core.util.security.pkcs7.PKCS7Signer;


/**
 * PDF document produced by <i>FPG</i>'s {@link PDFGenerator}.
 *
 * <BR>
 * <BR>
 *
 * <TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 *    <TBODY>
 *        <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
 *            <TH ALIGN="left" COLSPAN=4> <FONT SIZE="+2">
 *                 <B>Registro de Mantenciones</B></FONT>
 *            </TH>
 *        </TR>
 *
 *        <TR>
 *            <TD align="center"> <B>Fecha</B> </TD>
 *            <TD align="center"> <B>Versión</B> </TD>
 *            <TD> <B>Autor</B> </TD>
 *            <TD align="left"><B>Descripción</B></TD>
 *        </TR>
 *
 *        <TR BGCOLOR="white" CLASS="TableRowColor">
 *            <TD> 05-04-2008 </TD>
 *            <TD align="center"> 1.0 </TD>
 *            <TD> Germán Pavez I. <BR> gpavez@hotmail.com </TD>
 *            <TD> Versión inicial. </TD>
 *        </TR>
 *    </TBODY>
 * </TABLE>
 *
 * <BR>
 *
 * @author Germán Pavez I. (gpavez@hotmail.com)
 *
 * @version 1.0
 */
public class PDFDocument {

	/**
	 * PDF Fixed content size index.
	 */
	public static final int FIXED_CONTENT = 0;
	
	/**
	 * PDF Variable content size index.
	 */	
	public static final int VARIABLE_CONTENT = 1;
	
	/**
	 * PDF content size index.
	 */	
	public static final int TOTAL_CONTENT = 2;

	// Limits for generates /ByteRange when document needs be signed.
	private static final int MAX_NDIGITS_FOR_SECOND_SIZE = 8;

	// Number of objects added when document is signed.
	private static final int ADDED_OBJECTS_TO_SIGN = 4;

	private static final int PCKS7_SIGNATURE_MAX_SIZE = 2578;

	// Signature Filler: '<' PCKS7_SIGNATURE '>'
	private static final int SIGNATURE_FILLER_SIZE =
			1 + PCKS7_SIGNATURE_MAX_SIZE + 1;

	private static final byte[] signatureFiller;
	private static final String sTimeZoneOffset;

	private PDFGenerator generator;
	private DocumentModel documentModel;
	private String id;
	private String index;
	private int sequenceNumber;
	private PDFTemplate template;

	private int startxref;
	private Trailer trailer;
	private PDFPages pdfPages;

	private List addedXRefEntries = new LinkedList();
	private int nextObjID;

	private boolean debug;

	private Map caches = new HashMap();

	private ByteArrayOutputStream variableObjectsContent;

	private byte[] $variableObjectsContent;
	private byte[] $variableMetaDataContent;

	/*
	 * Variables used to sign.
	 */
	private boolean signed = false;

	private int acroFormObjID;	// Usedin Catalog object.
	private int firstSize;		// Used in ByteRange.
	private int secondOffset;	// Used in ByteRange.

	private boolean closed = false;

	static {

		/*
		 * General initialization to sign PDF documents.
		 */
		int[] timeZoneOffset = TimeZone.getTimeZoneOffset();

		sTimeZoneOffset =
				  Padder.lpad(timeZoneOffset[TimeZone.HOURS], 2, '0')
				+ '\''
				+ Padder.lpad(timeZoneOffset[TimeZone.MINUTES], 2, '0')
				+ '\'';

		signatureFiller = new byte[SIGNATURE_FILLER_SIZE];

		signatureFiller[0] = '<';

		for (int i = 1; i < signatureFiller.length - 1; i++) {
			signatureFiller[i] = '0';
		}

		signatureFiller[signatureFiller.length - 1] = '>';
	}

	/**
	 * Constructs a new PDF document instance to be generated by the specified
	 * generator instance using a document model instance.
	 * 
	 * @param generator PDF Generator.
	 * 
	 * @param documentModel Document model.
	 * 
	 * @param sequenceNumber Assigned sequence number.
	 * 
	 * @param referenceSize PDF document reference size in bytes.
	 */
	protected PDFDocument(PDFGenerator generator, DocumentModel documentModel,
			int sequenceNumber, int referenceSize) {

		this.generator = generator;
		this.documentModel = documentModel;
		id = documentModel.docID();
		index = documentModel.docIndex();
		this.sequenceNumber = sequenceNumber;
		template = generator.getTemplate();

		startxref = template.getStartXRef();
		trailer = (Trailer) template.getTrailer().clone();
		pdfPages = (PDFPages) template.getPDFPages().clone();

		nextObjID = trailer.nObjects;

		variableObjectsContent = new ByteArrayOutputStream(referenceSize);

		/*
		 * Reserves objIDs for root and /Catalog objects.
		 */
		trailer.rootObjID = nextObjID++;

		pdfPages.setObjID(nextObjID++);

		/*
		 * Reserves xref entry to /Pages object.
		 */
		XRefEntry xRefEntry = new XRefEntry();

		xRefEntry.assign(pdfPages.getObjID(), "pages");
		addedXRefEntries.add(xRefEntry);
	}

	/**
	 * Gets associated PDF Generator.
	 * 
	 * @return PDF Generator.
	 */
	public PDFGenerator getGenerator() {
		return generator;
	}

	/**
	 * Gets associated document model.
	 * 
	 * @return Associated document model.
	 */
	public DocumentModel getDocumentModel() {
		return documentModel;
	}

	/**
	 * Gets associated PDF template name.
	 * 
	 * @return Associated PDF template name.
	 */
	public String getTemplateName() {
		return template.getName();
	}

	/**
	 * Gets associated PDF template.
	 * 
	 * @return Associated PDF template.
	 */	
	public PDFTemplate getTemplate() {
		return template;
	}

	/**
	 * Gets assigned sequence number.
	 * 
	 * @return Assigned sequence number.
	 */
	public int getSequenceNumber() {
		return sequenceNumber;
	}

	/**
	 * Gets document type name.
	 * 
	 * @return Document type name.
	 */
	public String getType() {
		return template.getDocType();
	}

	/**
	 * Gets document version number.
	 * 
	 * @return Document version number.
	 */
	public int getVersion() {
		return template.getDocVersion();
	}

	/**
	 * Gets document ID.
	 * 
	 * @return Document ID.
	 */
	public String getID() {
		return id;
	}

	/**
	 * Gets document Index.
	 * 
	 * @return Document Index.
	 */	
	public String getIndex() {
		return index;
	}

	/**
	 * Gets PDF Pages object.
	 * 
	 * @return PDF Pages object.
	 */
	public PDFPages getPDFPages() {
		return pdfPages;
	}

	/**
	 * Gets number of pages.
	 * 
	 * @return Number of pages.
	 */
	public int pageCount() {
		return pdfPages.getKidObjIDs().size();
	}

	/**
	 * Gets offset in bytes to PDF cross reference.
	 * 
	 * @return PDF cross reference offset.
	 */
	public int getStartXRef() {
		return startxref;
	}

	/**
	 * Controls debug mode.
	 * 
	 * @param debug Debug mode control flag.
	 */
	public void setDebugMode(boolean debug) {
		this.debug = debug;
	}

	/**
	 * Indicates if debug mode is enabled or not.
	 * 
	 * @return <code>true</code> if debug mode is enabled,
	 *         otherwise <code>false</code>.
	 */	
	public boolean isDebugMode() {
		return debug;
	}

	/**
	 * Sets <b>ROOT</b> PDF Object ID. 
	 * 
	 * @param objID ROOT PDF Object ID.
	 */
	public void setRootObjID(int objID) {
		trailer.rootObjID = objID;
	}

	/**
	 * Sets <b>INFO</b> PDF Object ID.
	 * 
	 * @param objID INFO PDF Object ID.
	 */
	public void setInfoObjID(int objID) {
		trailer.infoObjID = objID;
	}

	/**
	 * Executes a linked PDF object. Generated output is deflated
	 * and added as a new PDF object to this document.
	 * 
	 * @param object Linked PDF object.
	 * 
	 * @throws FPGException If execution is failed.
	 * 
	 * @see #execute(PDFObject, boolean)
	 * @see #execute(PDFObject, boolean, boolean)
	 */
	public void execute(PDFObject object) throws FPGException {

		execute(object, true, true);
	}

	/**
	 * Executes a linked PDF object. Generated output is added as a
	 * new PDF object to this document. Output will be deflated or not
	 * depending of <code>deflate</code> control flag.
	 * 
	 * @param object Linked PDF object.
	 * 
	 * @param deflate Deflate control flag.
	 * 
	 * @throws FPGException If execution is failed.
	 * 
	 * @see #execute(PDFObject)
	 * @see #execute(PDFObject, boolean, boolean)
	 */
	public void execute(PDFObject object, boolean deflate) throws FPGException {

		execute(object, deflate, true);
	}

	/**
	 * Executes a linked PDF object. Output will be deflated or not depending
	 * of <code>deflate</code> control flag. Generated output is added as a
	 * new PDF object to this document if <code>addNew</code> control flag
	 * is <code>true</code>. 
	 * 
	 * @param object Linked PDF object.
	 * 
	 * @param deflate Deflate control flag.
	 * 
	 * @param addNew Add new PDF object control flag.
	 * 
	 * @throws FPGException If execution is failed.
	 * 
	 * @see #execute(PDFObject)
	 * @see #execute(PDFObject, boolean)
	 */
	public void execute(PDFObject object, boolean deflate, boolean addNew)
			throws FPGException {

		checkState(false);

		if (object.isLinked()) {
			generator.execute(this, object);
		} else {
			object.setXData(object.getData());
		}

		if (deflate) {
			generator.deflate(object);
		}

		if (addNew) {
			addNewObject(object);
		}
	}

	/**
	 * Adds a new PDF object to this PDF document.
	 * 
	 * @param object PDF object to be added.
	 * 
	 * @throws FPGException If PDF object cannot be added.
	 */
	public void addNewObject(PDFObject object) throws FPGException {

		checkState(false);

		int newObjID = nextObjID++;

		object.setNewObjID(newObjID);

		XRefEntry xRefEntry = new XRefEntry();

		xRefEntry.assign(newObjID, object.getBaseType());

		xRefEntry.offset = startxref;

		addedXRefEntries.add(xRefEntry);
		addObjectContent(newObjID, object.getXData());
	}

	private void addNewObject(int objID, byte[] objectData)
			throws FPGException {

		checkState(false);

		XRefEntry xRefEntry = new XRefEntry();

		xRefEntry.assign(objID, "internal");

		xRefEntry.offset = startxref;

		addedXRefEntries.add(xRefEntry);
		addObjectContent(objID, objectData);
	}

	/**
	 * Adds a new PDF Page to this PDF document.
	 * 
	 * @param newPage PDF Page to be added.
	 * 
	 * @throws FPGException If PDF Page cannot be added.
	 */
	public void addNewPage(PDFPage newPage) throws FPGException {

		checkState(false);

		int newObjID = nextObjID++;

		newPage.setObjID(newObjID);
		newPage.setParentObjID(pdfPages.getObjID());

		pdfPages.addKidObjID(newObjID);

		XRefEntry xRefEntry = new XRefEntry();

		xRefEntry.assign(newObjID, "page");

		xRefEntry.offset = startxref;

		addedXRefEntries.add(xRefEntry);
		addObjectContent(newObjID, newPage.assemble());
	}

	/**
	 * Signs this PDF document with the specified signer. This method is
	 * equivalent to call <code>sign(pkcs7Signer, null, null)</code>.
	 * 
	 * @param pkcs7Signer Signer.
	 * 
	 * @throws FPGException If cannot sign this document.
	 * 
	 * @see #sign(PKCS7Signer, String, String)
	 * @see #isSigned()
	 */	
	public void sign(PKCS7Signer pkcs7Signer) throws FPGException {
		sign(pkcs7Signer, null, null);
	}

	/**
	 * Signs this PDF document with the specified signer.
	 * 
	 * @param pkcs7Signer Signer.
	 * 
	 * @param title Sign Title.
	 * 
	 * @param reason Sign reason text.
	 * 
	 * @throws FPGException If cannot sign this document.
	 * 
	 * @see #sign(PKCS7Signer)
	 * @see #isSigned()
	 */
	public void sign(PKCS7Signer pkcs7Signer, String title, String reason)
			throws FPGException {

		/*
		 * Checks if it's possible sign.
		 */
		List pageObjIDs = pdfPages.getKidObjIDs();

		if (pageObjIDs.size() == 0) {
			throw new FPGException("Few many pages to sign.");
		}

		int firstPageObjID = ((Integer) pageObjIDs.get(0)).intValue();
		int defaultFontObjID = template.getDefaultFontObjID();

		if (defaultFontObjID == 0) {
			throw new FPGException(
					  "Undefined default font in PDF template "
					+ "'"
					+ template.getTemplateDir()
					+ "::"
					+ template.getName()
					+ "'.");
		}

		long signedTime = System.currentTimeMillis();
		AbsoluteDateTime aDateTime = new AbsoluteDateTime(signedTime);
		AbsoluteDate aDate = aDateTime.getAbsoluteDate();
		AbsoluteTime aTime = aDateTime.getAbsoluteTime();

		String sSignedTime =
				  aDate.toString(AbsoluteDate.YMD, "")
				+ aTime.toString("")
				+ "-"
				+ sTimeZoneOffset;

		/*
		 *
		 * PDF Objects updated or added to sign this document:
		 *
		 * UPDATED:
		 *
		 *     302 CATALOG						  REF 304
		 *
		 * ADDED:
		 *     304 ACROFORM						  VAR, REFS <def font>, 307
		 *     307 (Campo [Field] [FormElement])  VAR, REF 308
		 *     308 (Annotation)					  VAR, REFS 307, 265 (1st page)
		 *     309 (Firma Digital)				  VAR.
		 *
		 */
		acroFormObjID = nextObjID++;

		finish(true);

		int fieldObjID = nextObjID++;
		int annotationObjID = nextObjID++;
		int signatureObjID = nextObjID++;

		/*
		 * AcroForm.
		 */
		byte[] acroFormData =
				(  "<<\n"
				  + "/DR\n"
				  + "<<\n"
				  + "/Font\n"
				  + "<</Helv " + defaultFontObjID + " 0 R\n"
				  + ">>\n"
				  + ">>\n"
				  + "/DA(/Helv 0 Tf 0 g)\n"
				  + "/Fields[" + fieldObjID + " 0 R]\n"
				  + "/SigFlags 3\n"
				  + ">>\n"
				  + "endobj\n").getBytes();

		addNewObject(acroFormObjID, acroFormData);

		/*
		 * Field.
		 */
		if (title == null) {
			title = "Advanced Digital Signature";
		}

		byte[] fieldData =
				(   "<<\n"
				  + "/FT /Sig\n"
				  + "/V " + signatureObjID + " 0 R\n"
				  + "/T(" + title + ")\n"
				  + "/Kids[" + annotationObjID + " 0 R]\n"
				  + ">>\n"
				  + "endobj\n").getBytes();

		addNewObject(fieldObjID, fieldData);

		/*
		 * Annotation.
		 */
		byte[] annotationData =
				(   "<<\n"
				  + "/Type /Annot /Subtype /Widget\n"
				  + "/F 4\n"
				  + "/Parent " + fieldObjID + " 0 R\n"
				  + "/Rect[ 0 1008 0 1008]\n"
				  + "/P " + firstPageObjID + " 0 R\n"
				  + "/MK\n"
				  + "<<\n"
				  + "/BC[ 0 0 0]\n"
				  + "/R 270\n"
				  + ">>\n"
				  + "/H\n"
				  + "/N\n"
				  + ">>\n"
				  + "endobj\n").getBytes();

		addNewObject(annotationObjID, annotationData);

		/*
		 * Signature.
		 *
		 *      Header
		 *      Filler
		 *      Trailer
		 *
		 */
		byte[] signatureHeaderData =
				(   "<<\n"
				  + "/M(D:" + sSignedTime + ")\n"
				  + "/Filter /Adobe.PPKMS /SubFilter /adbe.pkcs7.detached\n"
				  + "/Contents").getBytes();

		firstSize =
				  startxref
				+ nDigits(signatureObjID) + 7	// |objID 0 obj\n|
				+ signatureHeaderData.length;

		secondOffset = firstSize + signatureFiller.length;

		addNewObject(signatureObjID, signatureHeaderData);

		variableObjectsContent.write(
				signatureFiller, 0, signatureFiller.length);

		if (reason == null) {
			reason = "";
		} else {
			reason = "/Reason(" + reason + ")\n";
		}

		byte[] signatureTrailerData =
				(   "\n"
				  + "/ByteRange[0 "
				  + firstSize + " "
				  + secondOffset + " 00000000]\n"
				  + reason
				  + ">>\n"
				  + "endobj\n").getBytes();

		variableObjectsContent.write(
				signatureTrailerData, 0, signatureTrailerData.length);

		startxref += signatureFiller.length + signatureTrailerData.length;

		close(pkcs7Signer);

		signed = true;
	}

	private void finish(boolean toSign) {

		/*
		 * Adds root /Catalog object.
		 */
		XRefEntry xRefEntry = new XRefEntry();

		xRefEntry.assign(trailer.rootObjID, "catalog");

		xRefEntry.offset = startxref;

		/*
		 * Catalog object was reserved as the first one. Hence
		 * it must mantain its position in cross reference.
		 */
		addedXRefEntries.add(0, xRefEntry);

		String acroForm =
				(toSign) ? "/AcroForm " + acroFormObjID + " 0 R\n" : "";

		byte[] catalogData =
				  (   "<<\n"
					+ "/Type /Catalog\n"
					+ "/Pages " + pdfPages.getObjID() + " 0 R\n"
					+ acroForm
					+ ">>\n"
					+ "endobj\n").getBytes();

		addObjectContent(trailer.rootObjID, catalogData);

		/*
		 * Adds /Pages object.
		 */
		pdfPages.adjustCount();

		xRefEntry = (XRefEntry) addedXRefEntries.get(1);

		xRefEntry.offset = startxref;

		addObjectContent(pdfPages.getObjID(), pdfPages.assemble());

		trailer.nObjects = template.getSize() + addedXRefEntries.size();

		if (toSign) {
			trailer.nObjects += ADDED_OBJECTS_TO_SIGN;
		}
	}

	/**
	 * Closes this PDF document. No more changes can be made later.
	 * 
	 * @throws FPGException If document cannot be closed.
	 */
	public void close() throws FPGException {

		close(null);
	}

	private void close(PKCS7Signer pkcs7Signer) throws FPGException {

		if (closed) {
			return;
		}

		if (pkcs7Signer == null) {
			finish(false);
		}

		caches.clear();

		caches = null;

		/*
		 * Unlinks generator and document model objects.
		 */
		generator = null;
		documentModel = null;

		closed = true;

		/*
		 * Close with signature?
		 */
		if (pkcs7Signer != null) {

			/*
			 * Determines content (previous to sign) and its size.
			 */
			int contentSize = 0;

			try {
				contentSize = getContentSize();
			} catch (FPGException e) {
				 // ASSERTION: Never occurs because document will be closed.
			}

			/*
			 * Caculates offset for signature filler:
			 *
			 *     /Contents<000000 ... 000000>
			 */
			int fixedOffset = template.getFixedObjectsContent().length - 1;
			int signatureOffset = firstSize - fixedOffset;

			/*
			 * Caculates offset for second size in ByteRange:
			 *
			 *     /ByteRange[0 firstSize secondOffset 00000000]
			 *                                         secondSize
			 */
			int secondSizeOffset =
					  secondOffset
					- fixedOffset
					+ 15
					+ nDigits(firstSize)
					+ nDigits(secondOffset);

			/*
			 * Updates content with second size in /ByteRange.
			 */
			int secondSize = contentSize - firstSize - signatureFiller.length;

			if (nDigits(secondSize) > MAX_NDIGITS_FOR_SECOND_SIZE) {
				throw new FPGException(
						"Document '" + id + "' too big to be signed.");
			}

			byte[] bSecondSize =
					Padder.lpad(
							secondSize,
							MAX_NDIGITS_FOR_SECOND_SIZE,
							' ').getBytes();

			System.arraycopy(
					bSecondSize,
					0,
					$variableObjectsContent,
					secondSizeOffset,
					bSecondSize.length);

			/*
			 * Calculate document's signature and updates its content with it.
			 */
			try {

				/*
				 * SIGN FIRST CONTENT BLOCK.
				 *
				 *     Fixed objects content of this document must
				 *     be precalculated to complete its signature
				 *     (PERFORMANCE REASON).
				 */
				byte[] fixedObjectsContent =
						template.getFixedObjectsContent();

				int variableObjectsContentLength =
						firstSize - fixedObjectsContent.length;

				pkcs7Signer.sign(
						$variableObjectsContent,
						0,
						variableObjectsContentLength);

				/*
				 * SIGN SECOND CONTENT BLOCK.
				 */
				pkcs7Signer.sign(
						$variableObjectsContent,
						variableObjectsContentLength + signatureFiller.length,
								  $variableObjectsContent.length
								- variableObjectsContentLength
								- signatureFiller.length);

				pkcs7Signer.sign(getFixedMetaDataContent());
				pkcs7Signer.sign($variableMetaDataContent);

				byte[] signature = pkcs7Signer.sign();

				/*
				 * Updates content with calculated signature.
				 */
				ByteArray.hexDump(
						signature,
						0,
						$variableObjectsContent,
						signatureOffset,
						signature.length);
			} catch (Exception e) {
				throw new FPGException(
						"Document '" + id + "' couldn´t be signed.", e);
			}
		}
	}

	/**
	 * Indicates if this PDF document is signed or not.
	 * 
	 * @return <code>true</code> if this PDF document is signed,
	 *         otherwise <code>false</code>.
	 *         
	 * @see #sign(PKCS7Signer)
	 * @see #sign(PKCS7Signer, String, String)
	 */
	public boolean isSigned() {
		return signed;
	}

	/**
	 * Indicates if this PDF document is closed or not. A closed PDF
	 * document don't permit more changes.
	 * 
	 * @return <code>true</code> if this PDF document is closed,
	 *         otherwise <code>false</code>.
	 *         
	 * @see #close()
	 */
	public boolean isClosed() {
		return closed;
	}

	/**
	 * Releases allocated resources to this document.
	 * 
	 * @throws FPGException If document is not closed.
	 */
	public void release() throws FPGException {

		checkState(true);

		variableObjectsContent = null;

		$variableObjectsContent = null;
		$variableMetaDataContent = null;

		template = null;
	}

	/**
	 * Gets sizes in bytes for fixed, variable and total PDF content.
	 * 
	 * @return PDF content sizes.
	 * 
	 * @throws FPGException If document is not closed.
	 */
	public int[] getContentSizes() throws FPGException {

		checkState(true);

		int [] stat = new int[3];

		stat[FIXED_CONTENT] =
				  getFixedObjectsContent().length
				+ getFixedMetaDataContent().length;

		stat[VARIABLE_CONTENT] =
				  getVariableObjectsContent().length
				+ getVariableMetaDataContent().length;

		stat[TOTAL_CONTENT] = stat[FIXED_CONTENT] + stat[VARIABLE_CONTENT];

		return stat;
	}

	/**
	 * Gets PDF document content size in bytes.
	 * 
	 * @return PDF document content size.
	 * 
	 * @throws FPGException If document is not closed.
	 * 
	 * @see #getContent()
	 */
	public int getContentSize() throws FPGException {

		checkState(true);

		return
				  getFixedObjectsContent().length
				+ getVariableObjectsContent().length
				+ getFixedMetaDataContent().length
				+ getVariableMetaDataContent().length;
	}
	
	/**
	 * Gets PDF document content.
	 * 
	 * @return PDF document content.
	 * 
	 * @throws FPGException If document is not closed.
	 * 
	 * @see #getContentSize()
	 */
	public byte[] getContent() throws FPGException {

		checkState(true);

		byte[] fixedObjectsContent = getFixedObjectsContent();
		byte[] variableObjectsContent = getVariableObjectsContent();
		byte[] fixedMetaDataContent = getFixedMetaDataContent();
		byte[] variableMetaDataContent = getVariableMetaDataContent();

		int contentLength =
				  fixedObjectsContent.length
				+ variableObjectsContent.length
				+ fixedMetaDataContent.length
				+ variableMetaDataContent.length;

		byte[] content = new byte[contentLength];
		int offset = 0;

		offset = ByteArray.copy(fixedObjectsContent, content, offset);
		offset = ByteArray.copy(variableObjectsContent, content, offset);
		offset = ByteArray.copy(fixedMetaDataContent, content, offset);
		offset = ByteArray.copy(variableMetaDataContent, content, offset);

		return content;
	}

	/**
	 * Writes this PDF document content to the specified output stream.
	 * 
	 * @param out Output stream.
	 * 
	 * @throws IOException If an I/O error occurs.
	 * 
	 * @throws FPGException If document is not closed.
	 */
	public void writeTo(OutputStream out)
			throws IOException, FPGException {

		checkState(true);

		out.write(getFixedObjectsContent());
		out.write(getVariableObjectsContent());
		out.write(getFixedMetaDataContent());
		out.write(getVariableMetaDataContent());
	}

	/**
	 * Gets Fixed PDF Object content.
	 * 
	 * @return Fixed PDF Object content.
	 * 
	 * @throws FPGException If document is not closed.
	 */
	public byte[] getFixedObjectsContent() throws FPGException {

		checkState(true);

		return template.getFixedObjectsContent();
	}

	/**
	 * Gets Variable PDF Object content.
	 * 
	 * @return Variable PDF Object content.
	 * 
	 * @throws FPGException If document is not closed.
	 */	
	public byte[] getVariableObjectsContent() throws FPGException {

		checkState(true);

		if ($variableObjectsContent == null) {
			byte[] startXref =
					("xref\n0 " + trailer.nObjects + " \n").getBytes();

			variableObjectsContent.write(startXref, 0, startXref.length);

			$variableObjectsContent = variableObjectsContent.toByteArray();
		}

		return $variableObjectsContent;
	}

	/**
	 * Gets Fixed PDF Metadata content.
	 * 
	 * @return Fixed PDF Metadata content.
	 * 
	 * @throws FPGException If document is not closed.
	 */
	public byte[] getFixedMetaDataContent() throws FPGException {

		checkState(true);

		return template.getFixedXRefContent();
	}

	/**
	 * Gets Variable PDF Metadata content.
	 * 
	 * @return Variable PDF Metadata content.
	 * 
	 * @throws FPGException If document is not closed.
	 */	
	public byte[] getVariableMetaDataContent() throws FPGException {

		checkState(true);

		if ($variableMetaDataContent == null) {
			byte[] trailerContent =
					PDFTemplate.trailerToByteArray(trailer, startxref);

			int nXRefEntries = addedXRefEntries.size();

			$variableMetaDataContent =
					new byte[
							  nXRefEntries * XRefEntry.SIZE
							+ trailerContent.length];

			/*
			 * Produces variable part of cross reference section.
			 *
			 * 0000000002 65535 f <space>
			 * 0000000312 00000 n <space>
			 */
			Iterator xRefIterator = addedXRefEntries.iterator();
			int offset = 0;

			for (int i = 0; i < nXRefEntries; i++) {
				XRefEntry xRefEntry = (XRefEntry) xRefIterator.next();

				byte[] entry =
						  (Padder.lpad(xRefEntry.offset, 10, '0')
						+ " "
						+ Padder.lpad(xRefEntry.value, 5, '0')
						+ " "
						+ xRefEntry.mark
						+ " \n").getBytes();

				offset =
						ByteArray.copy(entry, $variableMetaDataContent, offset);
			}

			/*
			 *  Produces variable part of trailer.
			 */
			ByteArray.copy(trailerContent, $variableMetaDataContent, offset);
		}

		return $variableMetaDataContent;
	}

	/**
	 * Gets number of PDF objects.
	 * 
	 * @return Number of PDF objects.
	 * 
	 * @throws FPGException If document is not closed.
	 */
	public int getSize() throws FPGException {

		checkState(true);

		return trailer.nObjects;
	}

	/**
	 * Creates a named cache to a PDF content.
	 * 
	 * @param name Named cache.
	 * 
	 * @param data PDF content to be cached.
	 */
	public void putCache(String name, byte[] data) {
		caches.put(name, data);
	}

	/**
	 * Gets a named cache.
	 * 
	 * @param name Named cache.
	 * 
	 * @return Cached PDF content.
	 */
	public byte[] getCache(String name) {
		return (byte[]) caches.get(name);
	}

	private void addObjectContent(int objID, byte[] data) {
		byte[] objectHeader = (objID + " 0 obj\n").getBytes();

		variableObjectsContent.write(objectHeader, 0, objectHeader.length);
		variableObjectsContent.write(data, 0, data.length);

		startxref += objectHeader.length + data.length;
	}

	private void checkState(boolean state) throws FPGException {

		if (state != closed) {
			String message =
					  "Document must be "
					+ ((state) ? "closed" : "opened");

			throw new FPGException(message);
		}
	}

	/* UNUSED.
	private void log(String message) {
		if (debug) {
			System.err.println("PDFDocument: " + message);
		}
	}
	*/

	private int nDigits(int n) {
		int nDigits = 1;

		n = Math.abs(n);

		while ((n / 10) > 0) {
			nDigits++;

			n = n / 10;
		}

		return nDigits;
	}
}
